CockroachDB (ya Google Spanner) jaise databases ko "Global-Scale Distributed SQL" databases kaha jata hai kyunki ye Synchronous Replication ko native tarike se handle karte hain.

Ek Staff Engineer ki nazar se, iska workflow aur aapke experience se connection kuch is tarah dikhega:

1. Synchronous "Quorum" Write
Jab India region mein request aati hai, CockroachDB internally Raft consensus algorithm use karta hai.

Transaction tabhi "Success" (Commit) maana jata hai jab majority nodes (e.g., 3 mein se 2 regions) data ko apne logs mein likh lete hain.

Iska matlab hai ki agar India mein write confirm hua hai, toh Europe ke paas woh data already physical disk par persist ho chuka hai.

2. Zero-Downtime Failover (RPO = 0, RTO is very low)
Agar India region suddenly down ho jata hai:

RPO (Recovery Point Objective) = 0: Aapka ek bhi transaction loss nahi hoga kyunki sync replication ki wajah se Europe ke paas latest state hai.

RTO (Recovery Method Objective): CockroachDB automatic leader election karta hai. Europe region ka node turant leader ban jayega aur traffic handle karne lagega.

Kyunki aapne Tier-0 mission-critical systems aur on-call/incident resolution  handle kiya hai, aap jante hain ki ye automation manual failover ke comparison mein kitna bada advantage hai.

3. Consistency Guarantee
Aapne Flipkart mein "Order Item Unit" granularity aur data consistency  par kaam kiya hai. CockroachDB wahi consistency global level par deta hai:


No Replication Lag: Kyunki write synchronous tha, Europe region ko "Eventually Consistent" data nahi dikhega; use hamesha Strongly Consistent data hi milega.


Idempotency: Aapki attribute_not_exists wali condition hamesha reliable rahegi, chahe request kisi bhi region mein redirect ho jaye.

DyncmoDb Global tables bhi use kiya ja sakta hai, wo multi region data replicate karta hai but async.

Sequence Diagram: Handling Region Failure
Aapne Flipkart mein Tier-0 systems ka on-call aur incident resolution handle kiya hai, toh aap is flow ki criticality samajh sakte hain:


Request Arives (India): Application putItem call karti hai with attribute_not_exists(Key).


Success: DynamoDB local commit karta hai aur background mein replicate shuru karta hai.


Disaster: India Region down ho jata hai.


Failover to Europe: Same request (Retry) Europe pahunchti hai.

Conflict Check: Europe region DynamoDB se check karta hai. Agar replication complete ho chuka hai, toh ConditionalCheckFailedException aayega aur transaction block ho jayega.

Critical Note: Agar replication complete nahi hua, toh Europe naya write allow kar sakta hai. Isse bachne ke liye payments mein External Consensus (jaise aapka Redis Lua approach ) ya Two-Phase Commit patterns ka sahara liya jata hai.

Agar aap DynamoDB use karte hain (jisme aapko experience bhi hai ), toh aap isse Conditional Writes ke saath use kar sakte hain:

Mechanism: Har transaction ke liye ek unique IdempotencyKey generate karein.

The Lock: Transaction shuru karne se pehle, Global Table mein ek record insert karein: putItem(IdempotencyKey, status=IN_PROGRESS) with a condition attribute_not_exists(IdempotencyKey).

Quorum: DynamoDB internally Paxos algorithm use karta hai. Jab aap "Strongly Consistent Read" ya "Conditional Write" karte hain, toh woh majority nodes (quorum) se confirm karta hai ki ye key pehle se exist toh nahi karti.

Failover: Agar India region down hota hai, toh Europe region mein wahi logic chalega. Kyunki data replicate ho chuka hai (ya write wahan commit hone ke baad hi success mila tha), Europe region doosra transaction block kar dega.

automatic failover to different region